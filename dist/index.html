<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Installation Node: Infinite</title>
    
    <!-- Google Fonts Preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Poppins', sans-serif;
            color: #e0e0e0;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: none;
        }
        
        /* Main artistic description overlay */
        #description-overlay {
            position: fixed;
            top: 50%;
            left: 4vw;
            transform: translateY(-50%);
            max-width: 45vw;
            z-index: 100;
            pointer-events: none;
            font-family: 'Poppins', sans-serif;
        }
        
        #description-overlay h1 {
            font-size: clamp(1.8rem, 4.5vw, 3.2rem);
            font-weight: 300;
            color: #ffffff;
            margin-bottom: 2.5vh;
            letter-spacing: 0.12em;
            line-height: 1.1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }
        
        #description-overlay p {
            font-size: clamp(0.8rem, 2.2vw, 1rem);
            line-height: 1.45;
            color: #d0d0d0;
            margin-bottom: 1vh;
            font-weight: 300;
            max-width: 42ch;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
            letter-spacing: 0.03em;
        }
        
        #description-overlay .continue-hint {
            font-size: clamp(0.7rem, 1.8vw, 0.85rem);
            opacity: 0.7;
            margin-top: 2.5vh;
            font-weight: 300;
            color: #b8b8b8;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.6);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        
        /* Bottom credits text */
        #credits-overlay {
            position: fixed;
            bottom: 0;
            left: 4vw;
            right: auto;
            width: auto;
            max-width: 300px;
            padding: 2vh 0;
            padding-bottom: calc(5vh + env(safe-area-inset-bottom));
            background: transparent;
            color: #a0a0a0;
            font-size: clamp(0.6rem, 1.5vw, 0.7rem);
            font-weight: 300;
            text-align: left;
            z-index: 50;
            font-family: 'Poppins', sans-serif;
            line-height: 1.4;
            letter-spacing: 0.02em;
        }
        
        #credits-overlay p {
            margin: 0.3vh 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.6);
        }
        
        #credits-overlay strong {
            color: #c0c0c0;
            font-weight: 400;
        }
        
        /* Mobile flat art typography - top-left layout */
        @media (max-width: 768px) {
            #description-overlay {
                top: 4vh;
                bottom: auto;
                left: 4vw;
                right: 4vw;
                max-width: 85vw;
                width: auto;
            }
            
            #description-overlay h1 {
                font-size: clamp(1.4rem, 6.5vw, 2.2rem);
                font-weight: 400;
                margin-bottom: 1.5vh;
                letter-spacing: 0.08em;
                line-height: 1.15;
            }
            
            #description-overlay p {
                font-size: clamp(0.7rem, 3vw, 0.85rem);
                line-height: 1.35;
                margin-bottom: 0.8vh;
                max-width: none;
            }
            
            #description-overlay .continue-hint {
                margin-top: 1.8vh;
                font-size: clamp(0.6rem, 2.5vw, 0.7rem);
            }
        }
        
        /* Extra small screen optimization */
        @media (max-width: 480px) {
            #description-overlay {
                bottom: 6vh;
                left: 4vw;
                right: 4vw;
            }
            
            #description-overlay h1 {
                font-size: clamp(1.5rem, 9vw, 2.2rem);
                letter-spacing: 0.1em;
            }
        }
    </style>
</head>
<body>

<div id="app-container">
    <canvas id="labyrinthCanvas"></canvas>
    
    <!-- Artistic Description Overlay -->
    <div id="description-overlay">
        <h1 class="poppins-light">THE INFINITE STRUCTURE</h1>
        <p class="poppins-regular">It is not a labyrinth to escape, nor a path to follow.</p>
        <p class="poppins-regular">It builds itself, endlessly, from within.</p>
        <p class="poppins-regular">Every wall is consistent, but the whole is undefined.</p>
        <p class="poppins-regular">You may move forward, yet never approach a center.</p>
        <p class="poppins-regular">Infinity is not an open field â€” it is a room that folds upon awareness itself.</p>
    </div>
    
    <!-- Credits Overlay -->
    <div id="credits-overlay">
        <p><strong>Sound</strong>: AI composition (AIMusicGen.AI)</p>
        <p><strong>Typeface</strong>: Poppins (Google Fonts)</p>
    </div>
    
    <!-- Ambient Music -->
    <audio id="ambientMusic" preload="auto" autoplay loop>
        <source src="../d6a09a35-81d1-4986-9737-00974566b557.mp3" type="audio/mpeg">
        <source src="https://cdn1.aimusicgen.ai/7/audios/d6a09a35-81d1-4986-9737-00974566b557.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

</div>
    
    <script type="module">
        /**
         * The Infinite Structure - Labyrinth Logic
         * A recursive, self-generating labyrinth that builds itself endlessly from within
         */
        class LabyrinthLogic {
            constructor(seed) {
                this.SEED = seed;
                this.CELL_SIZE = 20;
                this.EXPLORER_SPEED = 12.0;
                
                this.edgeCache = new Map();
                this.cellStateCache = new Map();
                this.visitedSet = new Set();
                this.ART_PARAMS = {};
                
                this.VISIBLE_CELLS_COUNT = 31;
                
                // Observer remains fixed at world coordinates (0, 0)
                this.OBSERVER_X = 0;
                this.OBSERVER_Y = 0;
                
                // Labyrinth "viewport" offset - the structure moves, not the observer
                this.viewportOffset = {
                    cellX: 0,
                    cellY: 0,
                    pixelX: 0,
                    pixelY: 0,
                    targetCellX: 0,
                    targetCellY: 0,
                    isMoving: false,
                    path: []
                };
                
                this.DIRECTIONS = [
                    { dir: 0, dx: 0, dy: -1 },
                    { dir: 1, dx: 1, dy: 0 },
                    { dir: 2, dx: 0, dy: 1 },
                    { dir: 3, dx: -1, dy: 0 }
                ];
                
                this.generateArtisticParameters();
            }
            
            randHash(x, y, d = 0) {
                if (x === 0 && y === 0 && d === 0) {
                    x = this.SEED; y = this.SEED; d = 10101;
                }
                
                let h = this.SEED ^ (x * 73856093) ^ (y * 19349663) ^ (d * 83492791);
                h = Math.imul(h ^ (h >>> 16), 2246822507);
                h = Math.imul(h ^ (h >>> 13), 3266489917);
                return ((h ^ (h >>> 16)) >>> 0) / 4294967296;
            }
            
            getKey(x, y) {
                return `${x},${y}`;
            }
            
            getOppositeDir(dirIndex) {
                return (dirIndex + 2) % 4;
            }
            
            mapRange(hash, min, max) {
                return min + hash * (max - min);
            }
            
            generateArtisticParameters() {
                this.ART_PARAMS.tunnelPreference = this.mapRange(this.randHash(0, 0, 1), 0.4, 0.8);
                this.ART_PARAMS.sparsityPenalty = this.mapRange(this.randHash(0, 0, 2), 0.05, 0.2);
                
                // Fixed colors
                this.ART_PARAMS.wallHue = 210;
                this.ART_PARAMS.visitedAlpha = 0.2;
                this.ART_PARAMS.explorerHue = 15;
                
                this.ART_PARAMS.turnPreferenceBoost = this.mapRange(this.randHash(0, 0, 6), 1.8, 2.8);
                this.ART_PARAMS.straightPreferenceBoost = this.mapRange(this.randHash(0, 0, 7), 1.2, 1.6);
                this.ART_PARAMS.diversityPenalty = this.mapRange(this.randHash(0, 0, 8), 0.1, 0.4);
            }
            
            isCellCarved(x, y) {
                return this.cellStateCache.get(this.getKey(x, y)) || false;
            }
            
            carveCell(x, y) {
                this.cellStateCache.set(this.getKey(x, y), true);
            }
            
            setEdgeState(x, y, dirIndex, isOpen) {
                const dir = this.DIRECTIONS[dirIndex];
                this.edgeCache.set(`${x},${y},${dirIndex}`, isOpen);
                const nx = x + dir.dx, ny = y + dir.dy;
                this.edgeCache.set(`${nx},${ny},${this.getOppositeDir(dirIndex)}`, isOpen);
            }
            
            isEdgeOpen(x, y, dirIndex) {
                const cacheKey = `${x},${y},${dirIndex}`;
                if (this.edgeCache.has(cacheKey)) return this.edgeCache.get(cacheKey);
                if (!this.isCellCarved(x, y)) this.generateLabyrinthStructure(x, y);
                else return false;
                return this.edgeCache.get(cacheKey) || false;
            }
            
            isPathOpen(x, y, dx, dy) {
                if (dx === 0 && dy === -1) return this.isEdgeOpen(x, y, 0);
                if (dx === 1 && dy === 0) return this.isEdgeOpen(x, y, 1);
                if (dx === 0 && dy === 1) return this.isEdgeOpen(x, y, 2);
                if (dx === -1 && dy === 0) return this.isEdgeOpen(x, y, 3);
                return false;
            }
            
            isEdgeOpenCached(x, y, dirIndex) {
                const cacheKey = `${x},${y},${dirIndex}`;
                return this.edgeCache.has(cacheKey) ? this.edgeCache.get(cacheKey) : false;
            }
            
            detectParallelCorridor(fromX, fromY, dirIndex, toX, toY) {
                const perpDir1 = (dirIndex + 1) % 4;
                const perpDir2 = (dirIndex + 3) % 4;
                let parallelCount = 0;
                
                for (const perpDir of [perpDir1, perpDir2]) {
                    const sideX = fromX + this.DIRECTIONS[perpDir].dx;
                    const sideY = fromY + this.DIRECTIONS[perpDir].dy;
                    
                    if (this.isCellCarved(sideX, sideY) && this.isEdgeOpenCached(sideX, sideY, dirIndex)) {
                        parallelCount++;
                        
                        const ahead1X = toX + this.DIRECTIONS[dirIndex].dx;
                        const ahead1Y = toY + this.DIRECTIONS[dirIndex].dy;
                        const sideAhead1X = sideX + this.DIRECTIONS[dirIndex].dx;
                        const sideAhead1Y = sideY + this.DIRECTIONS[dirIndex].dy;
                        
                        if (this.isCellCarved(ahead1X, ahead1Y) && 
                            this.isCellCarved(sideAhead1X, sideAhead1Y) &&
                            this.isEdgeOpenCached(sideX, sideY, dirIndex) &&
                            this.isEdgeOpenCached(sideAhead1X, sideAhead1Y, dirIndex)) {
                            parallelCount += 3;
                        }
                        
                        const ahead2X = ahead1X + this.DIRECTIONS[dirIndex].dx;
                        const ahead2Y = ahead1Y + this.DIRECTIONS[dirIndex].dy;
                        if (this.isCellCarved(ahead2X, ahead2Y) && this.isEdgeOpenCached(ahead1X, ahead1Y, dirIndex)) {
                            parallelCount += 2;
                        }
                    }
                }
                
                if (parallelCount === 0) return 1.0;
                if (parallelCount === 1) return 0.15;
                if (parallelCount === 2) return 0.05;
                if (parallelCount >= 3) return 0.01;
                return 0.005;
            }
            
            calculateDirectionBalance(centerX, centerY, proposedDir) {
                const checkRadius = 3;
                let horizontalCount = 0;
                let verticalCount = 0;
                
                for (let dy = -checkRadius; dy <= checkRadius; dy++) {
                    for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                        const x = centerX + dx;
                        const y = centerY + dy;
                        if (this.isCellCarved(x, y)) {
                            if (this.isEdgeOpenCached(x, y, 1) || this.isEdgeOpenCached(x, y, 3)) horizontalCount++;
                            if (this.isEdgeOpenCached(x, y, 0) || this.isEdgeOpenCached(x, y, 2)) verticalCount++;
                        }
                    }
                }
                
                const total = horizontalCount + verticalCount;
                if (total === 0) return 1.0;
                
                const hRatio = horizontalCount / total;
                const vRatio = verticalCount / total;
                
                if (proposedDir === 1 || proposedDir === 3) {
                    if (hRatio > 0.6) return 0.3;
                    if (hRatio > 0.55) return 0.6;
                    if (hRatio < 0.4) return 1.5;
                    return 1.0;
                } else {
                    if (vRatio > 0.6) return 0.3;
                    if (vRatio > 0.55) return 0.6;
                    if (vRatio < 0.4) return 1.5;
                    return 1.0;
                }
            }
            
            wouldCreateShortDeadEnd(nx, ny, fromX, fromY) {
                let potentialExits = 0;
                for (let i = 0; i < 4; i++) {
                    const dir = this.DIRECTIONS[i];
                    const checkX = nx + dir.dx;
                    const checkY = ny + dir.dy;
                    if (checkX === fromX && checkY === fromY) continue;
                    if (!this.isCellCarved(checkX, checkY)) {
                        potentialExits++;
                    }
                }
                
                // Stricter short dead-end detection: if only 1 or 0 potential exits, consider it a short dead-end
                if (potentialExits <= 1) return true;
                
                // Additional check: if there are too many dead-ends within 2 cells range, also consider it creates fragmented structure
                let nearbyDeadEnds = 0;
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const checkX = nx + dx;
                        const checkY = ny + dy;
                        if (this.isCellCarved(checkX, checkY)) {
                            let openDirs = 0;
                            for (let k = 0; k < 4; k++) {
                                if (this.isEdgeOpenCached(checkX, checkY, k)) {
                                    openDirs++;
                                }
                            }
                            if (openDirs === 1) nearbyDeadEnds++;
                        }
                    }
                }
                
                return nearbyDeadEnds >= 2; // If there are already 2 or more dead-ends nearby, avoid creating new ones
            }
            
            // Calculate distance to nearest junction, used to penalize extremely short passages
            getDistanceToNearestJunction(startX, startY, excludeDir) {
                let minDistance = Infinity;
                
                // Search in all directions from current position to find the nearest junction
                for (let searchDir = 0; searchDir < 4; searchDir++) {
                    if (searchDir === excludeDir) continue; // Exclude the direction about to be taken
                    
                    let distance = 0;
                    let currentX = startX;
                    let currentY = startY;
                    let currentDir = searchDir;
                    
                    // Search along this direction until finding a junction or dead-end
                    while (distance < 10) { // Limit search distance
                        const nextX = currentX + this.DIRECTIONS[currentDir].dx;
                        const nextY = currentY + this.DIRECTIONS[currentDir].dy;
                        
                        if (!this.isCellCarved(nextX, nextY)) break; // Hit a wall
                        if (!this.isEdgeOpenCached(currentX, currentY, currentDir)) break; // Path blocked
                        
                        currentX = nextX;
                        currentY = nextY;
                        distance++;
                        
                        // Check if current position is a junction (has more than 2 openings)
                        let openDirs = 0;
                        for (let k = 0; k < 4; k++) {
                            if (this.isEdgeOpenCached(currentX, currentY, k)) {
                                openDirs++;
                            }
                        }
                        
                        if (openDirs > 2) {
                            minDistance = Math.min(minDistance, distance);
                            break;
                        }
                        
                        // If it's a straight passage, continue in the same direction
                        if (openDirs === 2) {
                            // Find the next direction (not the direction we came from)
                            let nextDir = -1;
                            for (let k = 0; k < 4; k++) {
                                if (k !== (currentDir + 2) % 4 && this.isEdgeOpenCached(currentX, currentY, k)) {
                                    nextDir = k;
                                    break;
                                }
                            }
                            if (nextDir === -1) break;
                            currentDir = nextDir;
                        } else {
                            break; // Dead-end or other cases
                        }
                    }
                }
                
                return minDistance === Infinity ? 10 : minDistance; // If no junction found, return larger value
            }
            
            // Detect adjacent dead-end opening directions to prevent forming M, E, W type structures
            detectAdjacentDeadEndPattern(nx, ny, fromX, fromY, proposedDir) {
                // Check if adjacent positions have dead-ends with same opening direction
                const adjacentPositions = [
                    { x: nx - 1, y: ny }, // Left
                    { x: nx + 1, y: ny }, // Right
                    { x: nx, y: ny - 1 }, // Up
                    { x: nx, y: ny + 1 }  // Down
                ];
                
                for (const pos of adjacentPositions) {
                    if (pos.x === fromX && pos.y === fromY) continue;
                    if (!this.isCellCarved(pos.x, pos.y)) continue;
                    
                    // Check if this adjacent position is a dead-end
                    let openDirs = [];
                    for (let i = 0; i < 4; i++) {
                        if (this.isEdgeOpenCached(pos.x, pos.y, i)) {
                            openDirs.push(i);
                        }
                    }
                    
                    // If it's a dead-end (only one opening)
                    if (openDirs.length === 1) {
                        const existingDeadEndDir = openDirs[0];
                        // If new dead-end opening direction is same as existing dead-end, return penalty
                        if (existingDeadEndDir === proposedDir) {
                            return 0.01; // Heavy penalty
                        }
                        // If it's opposite direction (forming linear dead-ends), also give penalty
                        if (Math.abs(existingDeadEndDir - proposedDir) === 2) {
                            return 0.05; // Medium penalty
                        }
                    }
                }
                
                return 1.0; // No penalty
            }
            
            generateLabyrinthStructure(startX, startY) {
                if (this.isCellCarved(startX, startY)) return;
                
                const carvedThisRound = new Set();
                
                this.carveCell(startX, startY);
                carvedThisRound.add(this.getKey(startX, startY));
                
                let bestHash = -Infinity, bestDirIndex = -1;
                for (let i = 0; i < 4; i++) {
                    const dir = this.DIRECTIONS[i];
                    const nx = startX + dir.dx, ny = startY + dir.dy;
                    if (this.isCellCarved(nx, ny)) {
                        const connectionHash = this.randHash(startX, startY, 1000 + i * 123);
                        if (connectionHash > bestHash) {
                            bestHash = connectionHash;
                            bestDirIndex = i;
                        }
                    }
                }
                if (bestDirIndex !== -1) this.setEdgeState(startX, startY, bestDirIndex, true);
                
                const activeCells = [{ x: startX, y: startY, lastDir: -1 }];
                let maxIterations = this.VISIBLE_CELLS_COUNT * this.VISIBLE_CELLS_COUNT * 2;
                let iterations = 0;
                
                while (activeCells.length > 0 && iterations < maxIterations) {
                    iterations++;
                    
                    const currentLength = activeCells.length;
                    if (currentLength === 0) break;
                    
                    let cellIndex;
                    if (this.randHash(startX, startY, iterations) < this.ART_PARAMS.tunnelPreference) {
                        cellIndex = currentLength - 1;
                    } else {
                        cellIndex = Math.floor(this.randHash(startX, startY, iterations + 1) * currentLength);
                    }
                    cellIndex = Math.max(0, Math.min(cellIndex, currentLength - 1));
                    
                    const current = activeCells[cellIndex];
                    if (!current || typeof current.x !== 'number') {
                        activeCells.splice(cellIndex, 1);
                        continue;
                    }
                    
                    const neighborScores = [];
                    for (let i = 0; i < 4; i++) {
                        const dir = this.DIRECTIONS[i];
                        const nx = current.x + dir.dx, ny = current.y + dir.dy;
                        
                        if (!this.isCellCarved(nx, ny)) {
                            let score = 1.0;
                            
                            if (i === current.lastDir) {
                                score *= this.ART_PARAMS.straightPreferenceBoost;
                            } else if (current.lastDir !== -1) {
                                score *= this.ART_PARAMS.turnPreferenceBoost;
                            }
                            
                            let carvedNeighborsOfNewCell = 0;
                            for (let k = 0; k < 4; k++) {
                                const nextDir = this.DIRECTIONS[k];
                                const nnx = nx + nextDir.dx, nny = ny + nextDir.dy;
                                if (this.isCellCarved(nnx, nny) && (nnx !== current.x || nny !== current.y)) {
                                    carvedNeighborsOfNewCell++;
                                }
                            }
                            
                            if (carvedNeighborsOfNewCell >= 3) {
                                score *= this.ART_PARAMS.sparsityPenalty * 0.3;
                            } else if (carvedNeighborsOfNewCell === 2) {
                                score *= this.ART_PARAMS.sparsityPenalty;
                            } else if (carvedNeighborsOfNewCell === 1) {
                                score *= 0.7;
                            }
                            
                            // Additional penalty: check if it would create extremely short passage segments
                            // If distance from current position to nearest junction is too short, give penalty
                            let distanceToJunction = this.getDistanceToNearestJunction(current.x, current.y, i);
                            if (distanceToJunction < 3) {
                                score *= 0.4; // Heavy penalty for extremely short passages
                            } else if (distanceToJunction < 5) {
                                score *= 0.7; // Medium penalty for shorter passages
                            }
                            
                            if (this.wouldCreateShortDeadEnd(nx, ny, current.x, current.y)) {
                                score *= 0.05;
                                
                                // Check adjacent dead-end patterns to prevent forming M, E, W type structures
                                const adjacentDeadEndPenalty = this.detectAdjacentDeadEndPattern(nx, ny, current.x, current.y, i);
                                score *= adjacentDeadEndPenalty;
                            }
                            
                            const dirPerp1 = (i + 1) % 4;
                            const dirPerp2 = (i + 3) % 4;
                            const checkX1 = current.x + this.DIRECTIONS[dirPerp1].dx;
                            const checkY1 = current.y + this.DIRECTIONS[dirPerp1].dy;
                            const checkX2 = current.x + this.DIRECTIONS[dirPerp2].dx;
                            const checkY2 = current.y + this.DIRECTIONS[dirPerp2].dy;
                            
                            if (this.isCellCarved(checkX1, checkY1) && this.isEdgeOpenCached(checkX1, checkY1, i)) {
                                score *= this.ART_PARAMS.diversityPenalty * 0.5;
                            }
                            if (this.isCellCarved(checkX2, checkY2) && this.isEdgeOpenCached(checkX2, checkY2, i)) {
                                score *= this.ART_PARAMS.diversityPenalty * 0.5;
                            }
                            
                            const parallelPenalty = this.detectParallelCorridor(current.x, current.y, i, nx, ny);
                            score *= parallelPenalty;
                            
                            const directionBalance = this.calculateDirectionBalance(current.x, current.y, i);
                            score *= directionBalance;
                            
                            score *= this.randHash(nx, ny, iterations + i * 5);
                            neighborScores.push({ x: nx, y: ny, dirIndex: i, score: score });
                        }
                    }
                    
                    if (neighborScores.length > 0) {
                        neighborScores.sort((a, b) => b.score - a.score);
                        const nextNeighbor = neighborScores[0];
                        this.carveCell(nextNeighbor.x, nextNeighbor.y);
                        carvedThisRound.add(this.getKey(nextNeighbor.x, nextNeighbor.y));
                        this.setEdgeState(current.x, current.y, nextNeighbor.dirIndex, true);
                        activeCells.push({ x: nextNeighbor.x, y: nextNeighbor.y, lastDir: nextNeighbor.dirIndex });
                    } else {
                        activeCells.splice(cellIndex, 1);
                    }
                }
                
                this.ensureSmartBreathingHoles(startX, startY);
                this.softExtendShortDeadEnds(carvedThisRound);
            }
            
            ensureSmartBreathingHoles(centerX, centerY) {
                const range = Math.floor(this.VISIBLE_CELLS_COUNT / 2);
                let holesOpened = 0;
                
                for (let dy = -range; dy <= range; dy++) {
                    for (let dx = -range; dx <= range; dx++) {
                        const x = centerX + dx, y = centerY + dy;
                        if (this.isCellCarved(x, y)) continue;
                        
                        const carvedNeighbors = [];
                        for (let i = 0; i < 4; i++) {
                            const dir = this.DIRECTIONS[i];
                            const nx = x + dir.dx, ny = y + dir.dy;
                            if (this.isCellCarved(nx, ny)) {
                                carvedNeighbors.push(i);
                            }
                        }
                        
                        if (carvedNeighbors.length === 4) {
                            let bestDir = carvedNeighbors[0];
                            let bestParallelScore = -1;
                            
                            for (const dirIndex of carvedNeighbors) {
                                const toX = x + this.DIRECTIONS[dirIndex].dx;
                                const toY = y + this.DIRECTIONS[dirIndex].dy;
                                const parallelScore = this.detectParallelCorridor(x, y, dirIndex, toX, toY);
                                
                                if (parallelScore > bestParallelScore) {
                                    bestParallelScore = parallelScore;
                                    bestDir = dirIndex;
                                }
                            }
                            
                            this.setEdgeState(x, y, bestDir, true);
                            this.carveCell(x, y);
                            holesOpened++;
                        }
                    }
                }
                
                if (holesOpened > 0) {
                    // Smart breathing holes opened
                }
            }
            
            softExtendShortDeadEnds(carvedSet) {
                let extendedCount = 0;
                const originalCells = Array.from(carvedSet);
                
                for (const key of originalCells) {
                    const [x, y] = key.split(',').map(Number);
                    
                    const openDirs = [];
                    const uncarvedNeighbors = [];
                    for (let i = 0; i < 4; i++) {
                        if (this.isEdgeOpenCached(x, y, i)) {
                            openDirs.push(i);
                        } else {
                            const nx = x + this.DIRECTIONS[i].dx;
                            const ny = y + this.DIRECTIONS[i].dy;
                            if (!this.isCellCarved(nx, ny)) {
                                uncarvedNeighbors.push(i);
                            }
                        }
                    }
                    
                    if (openDirs.length !== 1) continue;
                    if (uncarvedNeighbors.length === 0) continue;
                    
                    let bestDir = uncarvedNeighbors[0];
                    let bestScore = -1;
                    for (const dirIndex of uncarvedNeighbors) {
                        const score = this.detectParallelCorridor(
                            x, y, dirIndex,
                            x + this.DIRECTIONS[dirIndex].dx,
                            y + this.DIRECTIONS[dirIndex].dy
                        );
                        if (score > bestScore) {
                            bestScore = score;
                            bestDir = dirIndex;
                        }
                    }
                    
                    // Force extend dead-ends at least 2-3 cells
                    let currentX = x, currentY = y;
                    let currentDir = bestDir;
                    let extensionLength = 0;
                    const minExtensionLength = 2 + Math.floor(this.randHash(x, y, 888) * 2); // 2-3 cells
                    
                    for (let step = 0; step < minExtensionLength; step++) {
                        const nextX = currentX + this.DIRECTIONS[currentDir].dx;
                        const nextY = currentY + this.DIRECTIONS[currentDir].dy;
                        
                        if (this.isCellCarved(nextX, nextY)) break; // If already carved, stop extension
                        
                        // Check if it would create too many connections
                        let carvedNeighbors = 0;
                        for (let k = 0; k < 4; k++) {
                            const checkX = nextX + this.DIRECTIONS[k].dx;
                            const checkY = nextY + this.DIRECTIONS[k].dy;
                            if (this.isCellCarved(checkX, checkY) && !(checkX === currentX && checkY === currentY)) {
                                carvedNeighbors++;
                            }
                        }
                        
                        if (carvedNeighbors > 1) break; // Avoid creating too many connections
                        
                        this.carveCell(nextX, nextY);
                        this.setEdgeState(currentX, currentY, currentDir, true);
                        extendedCount++;
                        extensionLength++;
                        
                        // Prepare next step: 70% chance to continue straight, 30% chance to turn
                        const continueHash = this.randHash(nextX, nextY, 999 + step);
                        if (continueHash < 0.7) {
                            // Continue straight
                            currentX = nextX;
                            currentY = nextY;
                        } else {
                            // Try to turn
                            const possibleTurns = [];
                            for (let k = 0; k < 4; k++) {
                                if (k === currentDir || k === (currentDir + 2) % 4) continue; // Exclude straight and backward
                                const turnX = nextX + this.DIRECTIONS[k].dx;
                                const turnY = nextY + this.DIRECTIONS[k].dy;
                                if (!this.isCellCarved(turnX, turnY)) {
                                    possibleTurns.push(k);
                                }
                            }
                            
                            if (possibleTurns.length > 0) {
                                currentDir = possibleTurns[Math.floor(this.randHash(nextX, nextY, 1111 + step) * possibleTurns.length)];
                                currentX = nextX;
                                currentY = nextY;
                            } else {
                                break; // Cannot turn, end extension
                            }
                        }
                    }
                }
                
                if (extendedCount > 0) {
                    // Enhanced extension completed
                }
            }
            
            getCurrentWorldPos() {
                return {
                    x: this.OBSERVER_X + this.viewportOffset.cellX,
                    y: this.OBSERVER_Y + this.viewportOffset.cellY
                };
            }
            
            findNextViewportMove() {
                if (this.viewportOffset.isMoving) return;
                
                const currentPos = this.getCurrentWorldPos();
                const startKey = this.getKey(currentPos.x, currentPos.y);
                const q = [{ x: currentPos.x, y: currentPos.y, path: [] }];
                const visitedInSearch = new Set([startKey]);
                const searchLimit = 500;
                
                while (q.length > 0 && visitedInSearch.size < searchLimit) {
                    const current = q.shift();
                    for (let i = 0; i < 4; i++) {
                        const dir = this.DIRECTIONS[i];
                        const nx = current.x + dir.dx, ny = current.y + dir.dy;
                        const nextKey = this.getKey(nx, ny);
                        const isWallOpen = this.isPathOpen(current.x, current.y, dir.dx, dir.dy);
                        
                        if (isWallOpen && !visitedInSearch.has(nextKey)) {
                            visitedInSearch.add(nextKey);
                            if (!this.visitedSet.has(nextKey)) {
                                this.viewportOffset.path = [...current.path, { x: nx, y: ny }];
                                this.viewportOffset.isMoving = true;
                                return;
                            }
                            q.push({ x: nx, y: ny, path: [...current.path, { x: nx, y: ny }] });
                        }
                    }
                }
                
                const possibleMoves = [];
                for (let i = 0; i < 4; i++) {
                    const d = this.DIRECTIONS[i];
                    if (this.isPathOpen(currentPos.x, currentPos.y, d.dx, d.dy)) {
                        possibleMoves.push({x: currentPos.x + d.dx, y: currentPos.y + d.dy});
                    }
                }
                
                if (possibleMoves.length > 0) {
                    const next = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    this.viewportOffset.path = [next];
                    this.viewportOffset.isMoving = true;
                }
            }
            
            updateViewport(deltaTime) {
                const currentPos = this.getCurrentWorldPos();
                this.visitedSet.add(this.getKey(currentPos.x, currentPos.y));
                
                if (!this.viewportOffset.isMoving) {
                    this.findNextViewportMove();
                    return;
                }
                
                if (this.viewportOffset.path.length === 0) {
                    this.viewportOffset.isMoving = false;
                    this.viewportOffset.pixelX = 0;
                    this.viewportOffset.pixelY = 0;
                    this.findNextViewportMove();
                    return;
                }
                
                const nextCell = this.viewportOffset.path[0];
                const currentWorldPos = this.getCurrentWorldPos();
                const dx = nextCell.x - currentWorldPos.x;
                const dy = nextCell.y - currentWorldPos.y;
                const moveStep = this.EXPLORER_SPEED * deltaTime;
                
                if (dx !== 0) {
                    const sign = Math.sign(dx);
                    this.viewportOffset.pixelX += sign * moveStep;
                    if (Math.abs(this.viewportOffset.pixelX) >= 1) {
                        this.viewportOffset.cellX += sign;
                        this.viewportOffset.pixelX = 0;
                        this.viewportOffset.path.shift();
                    }
                } else if (dy !== 0) {
                    const sign = Math.sign(dy);
                    this.viewportOffset.pixelY += sign * moveStep;
                    if (Math.abs(this.viewportOffset.pixelY) >= 1) {
                        this.viewportOffset.cellY += sign;
                        this.viewportOffset.pixelY = 0;
                        this.viewportOffset.path.shift();
                    }
                }
            }
            
            update(deltaTime) {
                this.updateViewport(deltaTime);
            }
        }

        /**
         * The Infinite Structure - WebGL Renderer
         * Renders the self-generating labyrinth with dynamic visual effects
         */
        class LabyrinthRendererWebGL {
            constructor(canvas, labyrinthLogic) {
                this.canvas = canvas;
                this.labyrinth = labyrinthLogic;
                
                // Initialize WebGL
                this.gl = canvas.getContext('webgl2', {
                    antialias: true,
                    alpha: false,
                    premultipliedAlpha: false
                });
                
                if (!this.gl) {
                    throw new Error('WebGL 2.0 not supported');
                }
                
                this.time = 0;
                this.lastViewportState = null; // Track viewport changes
                this.initShader();
                this.initGeometry();
                this.setupLabyrinthTexture();
                
                // WebGL renderer initialized
            }
            
            initShader() {
                const gl = this.gl;
                
                // Vertex shader
                const vertexSource = `#version 300 es
                    in vec2 position;
                    in vec2 texCoord;
                    out vec2 vTexCoord;
                    
                    void main() {
                        vTexCoord = texCoord;
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `;
                
                // Fragment shader - brand new dynamic effects
                const fragmentSource = `#version 300 es
                    precision highp float;
                    
                    in vec2 vTexCoord;
                    out vec4 fragColor;
                    
                    uniform sampler2D uLabyrinthTexture;
                    uniform float uTime;
                    uniform vec2 uResolution;
                    
                    // Simple noise function
                    float noise(vec2 p) {
                        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                    }
                    
                    // Smooth noise
                    float smoothNoise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);
                        
                        float a = noise(i);
                        float b = noise(i + vec2(1.0, 0.0));
                        float c = noise(i + vec2(0.0, 1.0));
                        float d = noise(i + vec2(1.0, 1.0));
                        
                        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                    }
                    
                    // Ripple effect
                    float ripple(vec2 uv, vec2 center, float time) {
                        float dist = length(uv - center);
                        return sin(dist * 15.0 - time * 3.0) * exp(-dist * 2.0) * 0.3;
                    }
                    
                    // Breathing glow - softer effect
                    float breathingGlow(float time) {
                        return 0.9 + 0.1 * sin(time * 1.2);
                    }
                    
                    // Flow effect
                    vec2 flowDistortion(vec2 uv, float time) {
                        float flow = smoothNoise(uv * 3.0 + vec2(time * 0.5, 0.0)) * 0.02;
                        return uv + vec2(flow, flow * 0.5);
                    }
                    
                    void main() {
                        vec2 uv = vTexCoord;
                        vec4 labyrinthColor = texture(uLabyrinthTexture, uv);
                        
                        // More refined TRAE-style background effect
                        vec2 fineGridUV = uv * 120.0; // Finer grid
                        vec2 fineGridID = floor(fineGridUV);
                        
                        // Static noise effect, avoiding hard boundaries
                        float fineNoise = smoothNoise(fineGridID * 0.1);
                        float subtlePattern = fineNoise * 0.01; // Very subtle static effect
                        
                        // Static subtle texture effect
                        float gentleFlow = sin(uv.x * 10.0) * sin(uv.y * 8.0) * 0.005;
                        
                        if (labyrinthColor.r > 0.3 && labyrinthColor.g < 0.3) {
                            // Walls - moderate green, ensuring visibility
                            vec3 baseColor = vec3(0.0, 0.5, 0.2); // Slightly increase brightness to ensure walls are visible
                            
                            // Radial breathing glow effect - spreading from center
                            vec2 center = vec2(0.5, 0.5);
                            float distFromCenter = length(uv - center);
                            
                            // Breathing effect - time-based pulse
                            float breathPulse = 0.7 + 0.3 * sin(uTime * 1.5);
                            
                            // Radial glow - spreading outward from center
                            float radialGlow = 1.0 - smoothstep(0.0, 0.8, distFromCenter);
                            radialGlow = pow(radialGlow, 2.0) * breathPulse;
                            
                            // Edge glow - soft green tech feel
                            vec2 pixelSize = 1.0 / uResolution;
                            float edge = 0.0;
                            edge += abs(texture(uLabyrinthTexture, uv + vec2(-pixelSize.x, 0.0)).r - labyrinthColor.r);
                            edge += abs(texture(uLabyrinthTexture, uv + vec2(pixelSize.x, 0.0)).r - labyrinthColor.r);
                            edge += abs(texture(uLabyrinthTexture, uv + vec2(0.0, -pixelSize.y)).r - labyrinthColor.r);
                            edge += abs(texture(uLabyrinthTexture, uv + vec2(0.0, pixelSize.y)).r - labyrinthColor.r);
                            
                            vec3 edgeGlow = vec3(0.0, 0.6, 0.3) * smoothstep(0.0, 1.0, edge) * 0.3;
                            
                            // Subtle vertical gradient effect - very slight, doesn't affect visibility
                            float subtleVerticalGradient = 0.8 + 0.2 * (1.0 - uv.y * 0.3);
                            
                            // Apply radial breathing glow effect and subtle vertical gradient
                            vec3 glowColor = vec3(0.0, 0.8, 0.4) * radialGlow * 0.4;
                            vec3 finalColor = (baseColor + glowColor + edgeGlow) * subtleVerticalGradient;
                            fragColor = vec4(finalColor, 1.0);
                            
                        } else if (labyrinthColor.g > 0.3 && labyrinthColor.r < 0.3) {
                            // Explorer - stable bright green, no color change
                            vec3 baseColor = vec3(0.2, 1.0, 0.6); // Stable bright green
                            
                            // Simple brightness pulse, no color change
                            float pulse = 0.9 + 0.1 * sin(uTime * 3.0);
                            
                            // Remove complex rotation and radial effects, keep color stable
                            vec3 finalColor = baseColor * pulse;
                            fragColor = vec4(finalColor, 1.0);
                            
                        } else if (labyrinthColor.b > 0.2 && labyrinthColor.r < 0.3 && labyrinthColor.g < 0.3) {
                            // Access trace - dark green trace
                            vec3 traceColor = vec3(0.0, 0.3, 0.15);
                            float traceFade = 0.4 + 0.1 * sin(uTime * 1.5);
                            fragColor = vec4(traceColor * traceFade, 0.6);
                            
                        } else {
                            // Background - refined TRAE-style dark background
                            vec3 baseColor = vec3(0.02, 0.05, 0.03); // Very deep green tone
                            
                            // Refined background texture effect
                            float backgroundTexture = subtlePattern + gentleFlow;
                            
                            // Radial gradient, slightly brighter at center
                            float radialGrad = 1.0 - length(uv - vec2(0.5)) * 0.3;
                            
                            // Static color shift
                            vec3 colorShift = vec3(
                                0.0,
                                0.002,
                                0.001
                            );
                            
                            // Add very subtle scanline effect
                            float scanlines = sin(uv.y * 800.0) * 0.003;
                            
                            vec3 finalColor = (baseColor + colorShift + vec3(0.0, backgroundTexture, backgroundTexture * 0.5) + vec3(0.0, scanlines, scanlines * 0.5)) * radialGrad;
                            fragColor = vec4(finalColor, 1.0);
                        }
                    }
                `;
                
                // Compiling shader
                
                const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentSource);
                
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    console.error('Program link error:', gl.getProgramInfoLog(this.program));
                    throw new Error('Shader program link failed');
                }
                
                // Shader compilation successful
            }
            
            compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const errorLog = gl.getShaderInfoLog(shader);
                    console.error('Shader compile error:', errorLog);
                    console.error('Shader source:', source);
                    gl.deleteShader(shader);
                    throw new Error('Shader compilation failed: ' + errorLog);
                }
                
                return shader;
            }
            
            initGeometry() {
                const gl = this.gl;
                
                // Fullscreen quad
                const vertices = new Float32Array([
                    -1, -1,  0, 0,
                     1, -1,  1, 0,
                    -1,  1,  0, 1,
                     1,  1,  1, 1
                ]);
                
                this.vbo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            }
            
            setupLabyrinthTexture() {
                const gl = this.gl;
                this.labyrinthTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.labyrinthTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                // Create temporary canvas for 2D rendering
                this.tempCanvas = document.createElement('canvas');
                this.tempCtx = this.tempCanvas.getContext('2d');
            }
            
            resize(width, height) {
                this.canvas.width = width;
                this.canvas.height = height;
                this.gl.viewport(0, 0, width, height);
                this.setupLabyrinthTexture();
            }
            
            renderLabyrinthToTexture() {
                const gl = this.gl;
                const labyrinth = this.labyrinth;
                
                // Only resize temporary canvas when needed
                if (this.tempCanvas.width !== this.canvas.width || this.tempCanvas.height !== this.canvas.height) {
                    this.tempCanvas.width = this.canvas.width;
                    this.tempCanvas.height = this.canvas.height;
                }
                const ctx = this.tempCtx;
                
                // Render maze to temporary canvas
                this.renderLabyrinthTo2D(ctx);
                
                // Upload to WebGL texture (using subImage2D for performance optimization)
                gl.bindTexture(gl.TEXTURE_2D, this.labyrinthTexture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.tempCanvas);
            }
            
            renderLabyrinthTo2D(ctx) {
                const labyrinth = this.labyrinth;
                const CELL_SIZE = labyrinth.CELL_SIZE;
                
                // Clear canvas with black background
                ctx.fillStyle = 'rgb(0, 0, 0)';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const cellsX = Math.floor(this.canvas.width / CELL_SIZE);
                const cellsY = Math.floor(this.canvas.height / CELL_SIZE);
                const halfCellsX = Math.floor(cellsX / 2);
                const halfCellsY = Math.floor(cellsY / 2);
                
                const viewCenterX = labyrinth.OBSERVER_X + labyrinth.viewportOffset.cellX;
                const viewCenterY = labyrinth.OBSERVER_Y + labyrinth.viewportOffset.cellY;
                
                const startGlobalX = viewCenterX - halfCellsX;
                const startGlobalY = viewCenterY - halfCellsY;
                
                // Use more precise sub-pixel offset calculation for smooth movement
                const pixelOffsetX = -labyrinth.viewportOffset.pixelX * CELL_SIZE;
                const pixelOffsetY = -labyrinth.viewportOffset.pixelY * CELL_SIZE;
                
                // Apply sub-pixel anti-aliasing to reduce visual artifacts
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                // Visited traces are not drawn in 2D rendering stage, already set to transparent in shader
                // This ensures visited cells are completely transparent without any color overlay
                
                // Draw walls (red channel) - increase wall thickness for better visibility
                ctx.strokeStyle = 'rgb(160, 0, 0)'; // Reduced from 220 to 160 for lower contrast
                ctx.lineWidth = 0.6; // Increased from 0.4 to 1.2 for better visibility
                ctx.lineCap = 'square';
                
                for (let j = 0; j < cellsY; j++) {
                    for (let i = 0; i < cellsX; i++) {
                        const globalX = startGlobalX + i;
                        const globalY = startGlobalY + j;
                        
                        let screenX = i * CELL_SIZE + pixelOffsetX;
                        let screenY = j * CELL_SIZE + pixelOffsetY;
                        
                        // Top wall
                        if (!labyrinth.isEdgeOpen(globalX, globalY, 0)) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY);
                            ctx.lineTo(screenX + CELL_SIZE, screenY);
                            ctx.stroke();
                        }
                        // Right wall
                        if (!labyrinth.isEdgeOpen(globalX, globalY, 1)) {
                            ctx.beginPath();
                            ctx.moveTo(screenX + CELL_SIZE, screenY);
                            ctx.lineTo(screenX + CELL_SIZE, screenY + CELL_SIZE);
                            ctx.stroke();
                        }
                        // Bottom wall
                        if (!labyrinth.isEdgeOpen(globalX, globalY, 2)) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY + CELL_SIZE);
                            ctx.lineTo(screenX + CELL_SIZE, screenY + CELL_SIZE);
                            ctx.stroke();
                        }
                        // Left wall
                        if (!labyrinth.isEdgeOpen(globalX, globalY, 3)) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY);
                            ctx.lineTo(screenX, screenY + CELL_SIZE);
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw observer point (green channel)
                const observerScreenX = halfCellsX * CELL_SIZE;
                const observerScreenY = halfCellsY * CELL_SIZE;
                const observerSize = CELL_SIZE * 0.8;
                const observerOffset = CELL_SIZE * 0.1;
                
                ctx.fillStyle = 'rgb(0, 180, 0)'; // Reduced from 255 to 180 for lower contrast
                ctx.fillRect(observerScreenX + observerOffset, observerScreenY + observerOffset, observerSize, observerSize);
            }
            
            render(deltaTime) {
                this.time += deltaTime;
                
                const gl = this.gl;
                const labyrinth = this.labyrinth;
                
                // Check if viewport has changed
                const currentViewportState = {
                    cellX: labyrinth.viewportOffset.cellX,
                    cellY: labyrinth.viewportOffset.cellY,
                    pixelX: labyrinth.viewportOffset.pixelX,
                    pixelY: labyrinth.viewportOffset.pixelY,
                    visitedCount: labyrinth.visitedSet.size
                };
                
                const viewportChanged = !this.lastViewportState || 
                    this.lastViewportState.cellX !== currentViewportState.cellX ||
                    this.lastViewportState.cellY !== currentViewportState.cellY ||
                    this.lastViewportState.pixelX !== currentViewportState.pixelX ||
                    this.lastViewportState.pixelY !== currentViewportState.pixelY ||
                    this.lastViewportState.visitedCount !== currentViewportState.visitedCount;
                
                // Always update texture during movement to ensure smooth sub-pixel movement
                if (viewportChanged || labyrinth.viewportOffset.isMoving) {
                    this.renderLabyrinthToTexture();
                    this.lastViewportState = currentViewportState;
                }
                
                // Apply shader effects
                gl.useProgram(this.program);
                
                // Set vertex attributes
                const posLoc = gl.getAttribLocation(this.program, 'position');
                const texLoc = gl.getAttribLocation(this.program, 'texCoord');
                
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
                gl.enableVertexAttribArray(texLoc);
                gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 16, 8);
                
                // Set uniforms
                const timeLoc = gl.getUniformLocation(this.program, 'uTime');
                const resLoc = gl.getUniformLocation(this.program, 'uResolution');
                const textureLoc = gl.getUniformLocation(this.program, 'uLabyrinthTexture');
                
                gl.uniform1f(timeLoc, this.time);
                gl.uniform2f(resLoc, this.canvas.width, this.canvas.height);
                gl.uniform1i(textureLoc, 0);
                
                // Bind labyrinth texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.labyrinthTexture);
                
                // Render fullscreen quad
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // Initialize the application
        const canvas = document.getElementById('labyrinthCanvas');
        const descriptionOverlay = document.getElementById('description-overlay');
        const ambientMusic = document.getElementById('ambientMusic');
        
        // Initialize
        const SEED = Math.floor(Math.random() * 1000000);
        
        let labyrinth, renderer;
        let isInitialized = false;
        let lastTime = 0;
        let hasStarted = false;
        let musicPlaying = false;
        let userInteracted = false;
        
        // Set initial volume and handle autoplay restrictions
        if (ambientMusic) {
            ambientMusic.volume = 0.3;
            
            // Handle autoplay restrictions gracefully
            ambientMusic.addEventListener('loadeddata', () => {
                if (!userInteracted) {
                    ambientMusic.play().catch(e => {
                        // If autoplay fails, wait for user interaction
                        if (e.name === 'NotAllowedError') {
                            // Add interaction listeners for fallback
                            ['click', 'touchstart', 'keydown'].forEach(event => {
                                document.addEventListener(event, () => {
                                    if (!userInteracted) {
                                        userInteracted = true;
                                        ambientMusic.play().catch(() => {});
                                    }
                                }, { once: true });
                            });
                        }
                    });
                }
            });
            
            // Handle audio loading errors gracefully
            ambientMusic.addEventListener('error', (e) => {
                // Silent error handling
            });
        }
        
        // Initialize labyrinth and renderer
        try {
            labyrinth = new LabyrinthLogic(SEED);
            renderer = new LabyrinthRendererWebGL(canvas, labyrinth);
            isInitialized = true;
        } catch (error) {
            throw error;
        }
        
        // Canvas resize handling
        function resizeCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            canvas.width = width;
            canvas.height = height;
            
            if (renderer) {
                renderer.resize(width, height);
            }
        }
        
        // Initial resize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Main experience loop
        function experienceLoop(currentTime) {
            if (!isInitialized) return;
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            if (!hasStarted) {
                hasStarted = true;
                // Music will autoplay due to HTML attributes
            }
            
            // Update labyrinth logic
            labyrinth.update(deltaTime);
            
            // Render
            if (renderer) {
                renderer.render(deltaTime);
            }
            
            requestAnimationFrame(experienceLoop);
        }
        
        // Start the experience
        requestAnimationFrame(experienceLoop);
    </script>
</body>
</html>